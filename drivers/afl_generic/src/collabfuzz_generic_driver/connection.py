from .seedmsg_pb2 import SeedMsg, JobMsg, TestCaseReportReply
from .fuzzerctrlmsg_pb2 import FuzzerCtrlMsg, CtrlCommand
from .config import Config, FuzzerType

import logging
from enum import Enum
from typing import Union, Optional
from datetime import timedelta

import zmq

logger = logging.getLogger(__name__)


class ConnectionException(Exception):
    pass


class TimeoutExpired(Exception):
    pass


class _MessageType(Enum):
    CONTROL = b"C"
    SEED = b"S"


class FrameworkConnection:
    # How often the driver should report to the log when waiting
    REPORT_TIMEOUT = timedelta(seconds=1)

    # How long before the driver gives up on receiving a response from the server
    MAX_SOCKET_TIMEOUT = timedelta(seconds=10)

    def __init__(self, config: Config):
        # Only a single ZeroMQ context should be used for the whole process
        zmq_ctx = zmq.Context.instance()

        self._ctrl_socket = zmq_ctx.socket(zmq.REQ)
        self._pull_socket = zmq_ctx.socket(zmq.SUB)
        self._report_socket = zmq_ctx.socket(zmq.REQ)

        # LINGER needs to be set to 0 to allow the user to kill the program when
        # the server cannot be reached
        self._ctrl_socket.LINGER = 0
        self._pull_socket.LINGER = 0
        self._pull_socket.LINGER = 0

        self.__connect(config)

    def __register_fuzzer(self, fuzzer_type: FuzzerType) -> str:
        # The ID of the fuzzer, which is needed to connect the pull socket, is
        # generated by the server and is received upon registration. As a
        # consequence, registration has to be performed before connecting the
        # other sockets.

        logger.debug("Initiating fuzzer registration")
        register_msg = FuzzerCtrlMsg()
        register_msg.command = CtrlCommand.COMMAND_REGISTER
        register_msg.fuzzer_type = fuzzer_type.to_pb2_type()
        self.__send_message(self._ctrl_socket, register_msg)

        id_msg = self.__receive_message(self._ctrl_socket)
        if not isinstance(id_msg, FuzzerCtrlMsg):
            raise ConnectionException(
                f"Received wrong response on registration: {id_msg}"
            )
        if id_msg.command != CtrlCommand.COMMAND_REGISTER:
            raise ConnectionException(
                f"Received wrong ctrl message type on registration: {id_msg}"
            )

        return id_msg.fuzzer_id

    def __connect(self, config: Config) -> None:
        self._ctrl_socket.connect(config.ctrl_uri)
        logger.info(f"Control socket connected to: {config.ctrl_uri}")

        try:
            self._fuzzer_id = self.__register_fuzzer(config.fuzzer_type)
            logger.info(f"Fuzzer ID received: {self._fuzzer_id}")
        except:  # noqa: E722
            # Close control socket if initialization fails, since the
            # connection is not completely open, it should not be closed
            self._ctrl_socket.close()
            raise

        self._pull_socket.SUBSCRIBE = self._fuzzer_id.encode()
        self._pull_socket.SUBSCRIBE = "000".encode()
        self._pull_socket.connect(config.pull_uri)
        logger.info(f"Pull socket connected to: {config.pull_uri}")

        self._report_socket.connect(config.push_uri)
        logger.info(f"Report socket connected to: {config.push_uri}")

    def __send_message(
        self, socket: zmq.Socket, msg: Union[SeedMsg, FuzzerCtrlMsg]
    ) -> None:
        if type(msg) == FuzzerCtrlMsg:
            msg_type = _MessageType.CONTROL.value
        elif type(msg) == SeedMsg:
            msg_type = _MessageType.SEED.value
        else:
            raise ValueError(f"Unknown message type: {type(msg)}")

        socket.send_multipart((msg_type, msg.SerializeToString()))

    def __receive_message(self, socket: zmq.Socket) -> Union[FuzzerCtrlMsg, JobMsg]:
        msg_type, raw_msg = socket.recv_multipart()

        if msg_type == _MessageType.CONTROL.value:
            ctrl_msg = FuzzerCtrlMsg()
            ctrl_msg.ParseFromString(raw_msg)
            return ctrl_msg
        elif msg_type == _MessageType.SEED.value:
            # JobMsg are marked with "S" in the protocol
            job_msg = JobMsg()
            job_msg.ParseFromString(raw_msg)
            return job_msg
        else:
            raise ConnectionException(
                f"Received message with unsupported type: {msg_type}"
            )

    def push_test_case(self, test_case: SeedMsg) -> str:
        test_case.fuzzer_id = self._fuzzer_id

        logger.debug("Sending test case to server")
        self.__send_message(self._report_socket, test_case)

        logger.debug("Receiving report reply")
        self.__poll_socket(self._report_socket)

        reply_encoded = self._report_socket.recv()
        report_reply = TestCaseReportReply()
        report_reply.ParseFromString(reply_encoded)

        if report_reply.HasField("error"):
            raise ConnectionException(
                f"Received error while reporting seed: {report_reply.error}"
            )

        logger.info(f"Pushed test case, server ID: {report_reply.id}")

        return report_reply.id

    def pull_from_server(
        self, timeout: Optional[int] = None
    ) -> Union[JobMsg, FuzzerCtrlMsg]:
        # The timeout is needed to avoid making pulling a fully blocking
        # operation. This is useful to gracefully shut down the listening
        # thread.
        if self._pull_socket.poll(timeout) == 0:
            raise TimeoutExpired

        topic = self._pull_socket.recv()  # The topic is discarded
        logger.debug(f"Received message with topic: {topic}")
        msg = self.__receive_message(self._pull_socket)

        if isinstance(msg, JobMsg):
            logger.info(f"Received {len(msg.seeds)} seeds")
        else:
            logger.info(f"Received {msg.command} control message")

        return msg

    def report_ready(self) -> None:
        logger.debug("Sending ready message")
        ready_msg = FuzzerCtrlMsg()
        ready_msg.command = CtrlCommand.COMMAND_READY
        ready_msg.fuzzer_id = self._fuzzer_id
        self.__send_message(self._ctrl_socket, ready_msg)

        # If the framework is not responding to the READY message, avoid
        # remaining blocked on the request. This is needed to gracefully shut
        # down the driver.
        logger.debug("Waiting for ACK response")
        self.__poll_socket(self._ctrl_socket)

        msg = self.__receive_message(self._ctrl_socket)
        if not isinstance(msg, FuzzerCtrlMsg):
            raise ConnectionException(
                f"Got non-control message when waiting for ACK: {msg}"
            )
        if msg.command != CtrlCommand.COMMAND_ACK:
            raise ConnectionException(
                f"Got non-ACK message when waiting for ACK: {msg}"
            )

        logger.info(f"Fuzzer reported ready for next input")

    def __deregister_fuzzer(self) -> None:
        ready_msg = FuzzerCtrlMsg()
        ready_msg.command = CtrlCommand.COMMAND_DEREGISTER
        ready_msg.fuzzer_id = self._fuzzer_id
        self.__send_message(self._ctrl_socket, ready_msg)

        # If the framework is not responding to the DEREGISTER message, avoid
        # remaining blocked on the request.
        logger.debug("Waiting for deregister response")
        self.__poll_socket(self._ctrl_socket)

        msg = self.__receive_message(self._ctrl_socket)
        if not isinstance(msg, FuzzerCtrlMsg):
            raise ConnectionException(
                f"Got non-control message when waiting for ACK: {msg}"
            )
        if msg.command != CtrlCommand.COMMAND_ACK:
            raise ConnectionException(
                f"Got non-ACK message when waiting for ACK: {msg}"
            )

    def close(self, timeout: int = None) -> None:
        try:
            logger.debug("Attempting driver deregistration")
            self.__deregister_fuzzer()
            logger.info("Driver correctly deregistered from server")

        except (ConnectionException, zmq.error.ZMQError) as e:
            # Since the connection is being closed anyway, it does not make
            # sense to throw exceptions, make sure to log them though
            logger.warning(f"Deregistration failed: {e}")

        finally:
            self._ctrl_socket.close()
            self._pull_socket.close()
            self._report_socket.close()

            logger.info("Connection closed.")

    def __poll_socket(self, socket: zmq.Socket) -> int:
        waited_time = timedelta()

        report_timeout_ms = self.REPORT_TIMEOUT / timedelta(milliseconds=1)
        while socket.poll(report_timeout_ms) == 0:
            waited_time += self.REPORT_TIMEOUT
            logger.warning(f"Polled socket for {waited_time}")

            if waited_time >= self.MAX_SOCKET_TIMEOUT:
                raise ConnectionException(f"Polling timed out")

        return socket.poll()
